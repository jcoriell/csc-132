[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Science of Computing III",
    "section": "",
    "text": "01 More on Data Structures\n02 More on Objects\n03 Building a Computer\n04 Beam - Problem Solving with Computers\n05 Beam - Software Engineering\n06 Algorithms…Reloaded\n07 Beam - Artificial Intelligence\n08 Beam - Git for Beginners"
  },
  {
    "objectID": "index.html#lessons",
    "href": "index.html#lessons",
    "title": "The Science of Computing III",
    "section": "",
    "text": "01 More on Data Structures\n02 More on Objects\n03 Building a Computer\n04 Beam - Problem Solving with Computers\n05 Beam - Software Engineering\n06 Algorithms…Reloaded\n07 Beam - Artificial Intelligence\n08 Beam - Git for Beginners"
  },
  {
    "objectID": "lessons/02 More on Objects/index.html",
    "href": "lessons/02 More on Objects/index.html",
    "title": "02 More on Objects",
    "section": "",
    "text": "The last major topic that was discussed in the object-oriented paradigm was inheritance. To review, there are cases where it is advantageous to have one class (called a subclass) inherit state and behavior from another class (called a superclass). Using inheritance allows us, among many other things, to avoid excessive repetition and code duplication. This makes maintaining code much easier.\nAs an example, let’s assume that you are writing a program to store information about the kinds of vehicles that a car mechanic’s garage may deal with on a daily basis. For simplicity, suppose that the mechanic only keeps track of the number of tires that a car has (yes, there are some cars that have three tires), whether the car has a working engine, and the car’s owner. In this case, the car class would need three instance variables (one for each of the mentioned attributes). It may even have a function that allows a car’s information to be output in a meaningful way (i.e., it would implement a __str__ method). Even though the class is very basic, we’ll use it to make a point. Here is the source code for the Car class, along with some sample testing code in the main part of the program:\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nprint(c1)\nOf course, the output is fairly simple to determine:\nCar; owner=John, tires=4, engine=True\nNow consider the case where, one day, the mechanic’s garage decides to repair bicycles as well. A very quick fix would be to create a similar class just for bicycles. In fact, here are comparisons of the Car and Bicycle classes (with a slightly modified main part of the program):\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Bicycle:\n\n    def __init__(self, name):\n        self.tires = 2\n        self.engine = False\n        self.owner = name\n\n    def __str__(self):\n        return \"Bicycle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\n\nprint(c1)\nprint(b1)\nAnd here is the output of this modified program:\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nNotice the code duplication? In fact, the Bicycle class is almost an exact copy of the Car class. The only differences are that a bicycle has only two tires, has no engine, and is called a bicycle. As you might imagine, creating similar classes this way gets very ineffective the larger classes get, and the more classes an application requires. For example, what would need to be done if the garage decided to repair motorcycles as well? Expanding the example above, another class would have to be created. In fact, it would also be very similar to the Car class.\nWhat would happen if a mistake were made in the source code that implements the way that tires are accounted for? Or suppose that an adjustment needed to be made (e.g., adding another instance variable to keep track of a spare tire). In the best case, modifications to all three classes would have to be made, thereby increasing the chances of making mistakes and causing errors.\nAs discussed previously, the concept of inheritance allows us to create a superclass that can encapsulate all of the common members that one or more subclasses can share. The subclasses that are created from some superclass can be considered to be specific subtypes of the superclass.\nOne way to modify the code in the example above to utilize inheritance is to create a Vehicle superclass that defines all of the members that are shared among all types of vehicles in the application: cars, bicycle, and motorcycles. The car, bicycle, and motorcycle classes would then inherit from and become subclasses of the Vehicle class. This greatly helps to reduce code duplication. To illustrate this, here are modified classes, along with some test code, that updates the classes above and implements inheritance:\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n    def __str__(self):\n        return \"Car; \" + super().__str__()\n\n\nclass Bicycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle; \" + super().__str__()\n\n\nclass Motorcycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(b1)\nprint(m1)\nAnd here is the output of the program\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nMotorcycle; owner=Randy, tires=2, engine=True\nLook over the code above and see if it makes sense to you. Notice the default values of None for the variables tires and engine. These values are overwritten in the subclasses, depending on which subclass is initialized, as follows:\n\n\n\nClass\ntires\nengine\n\n\n\n\nVehicle\nNone\nNone\n\n\nCar\n4\nTrue\n\n\nBicycle\n2\nFalse\n\n\nMotorcycle\n2\nTrue\n\n\n\nAlso notice that the constructor of the Vehicle class (the superclass) is called in the constructor of each of the subclasses. In fact, this is the first statement in the constructors of the subclasses. That is, the initialization of a car, bicycle, and motorcycle first means to initialize a vehicle. This sets default values for the variables tires and engine. The owner of the vehicle is passed in when instantiating each of the subclasses, and is forwarded to the superclass (where the value is formally assigned). Any remaining initialization of the subclasses is done after the call to the constructor in the superclass (i.e., specific values for the variables tires and engine).\nAlso, the class output magic function __str__ also calls the matching function in the Vehicle superclass. Why? Well, it actually generates the appropriate output for any kind of vehicle (i.e., owner, number of tires, and whether or not it has an engine). The only distinguishing characteristic is the actual name of the class. Therefore, the subclasses first generate a string matching their name followed by a call to the superclass function (which generates a string containing the information specified above).\nAs a last modification, note that bicycles and motorcycles have the same number of tires. Since we can have many levels of inheritance, let’s try to add a generic Cycle class that encapsulates the attributes shared by all kinds of cycles (i.e., bicycles and motorcycles). To be clear, the application now has the following class diagram:\n\n\n\nClass diagram of Vehicle, Car, Cycle, Bicycle, and Motorcycle\n\n\n\n\n\n\n\n\nActivity\n\n\n\nImplement the Cycle class; then, modify the Bicycle and Motorcycle classes to inherit from the Cycle class.\n\n\nThe act of designing an application, particularly a large one, requires consideration of many factors that help to ensure its success. That is, there are ideas that must be considered in order to make designing an application easier. Much of the remainder of this lesson is dedicated to identifying such techniques."
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#inheritance",
    "href": "lessons/02 More on Objects/index.html#inheritance",
    "title": "02 More on Objects",
    "section": "",
    "text": "The last major topic that was discussed in the object-oriented paradigm was inheritance. To review, there are cases where it is advantageous to have one class (called a subclass) inherit state and behavior from another class (called a superclass). Using inheritance allows us, among many other things, to avoid excessive repetition and code duplication. This makes maintaining code much easier.\nAs an example, let’s assume that you are writing a program to store information about the kinds of vehicles that a car mechanic’s garage may deal with on a daily basis. For simplicity, suppose that the mechanic only keeps track of the number of tires that a car has (yes, there are some cars that have three tires), whether the car has a working engine, and the car’s owner. In this case, the car class would need three instance variables (one for each of the mentioned attributes). It may even have a function that allows a car’s information to be output in a meaningful way (i.e., it would implement a __str__ method). Even though the class is very basic, we’ll use it to make a point. Here is the source code for the Car class, along with some sample testing code in the main part of the program:\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nprint(c1)\nOf course, the output is fairly simple to determine:\nCar; owner=John, tires=4, engine=True\nNow consider the case where, one day, the mechanic’s garage decides to repair bicycles as well. A very quick fix would be to create a similar class just for bicycles. In fact, here are comparisons of the Car and Bicycle classes (with a slightly modified main part of the program):\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Bicycle:\n\n    def __init__(self, name):\n        self.tires = 2\n        self.engine = False\n        self.owner = name\n\n    def __str__(self):\n        return \"Bicycle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\n\nprint(c1)\nprint(b1)\nAnd here is the output of this modified program:\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nNotice the code duplication? In fact, the Bicycle class is almost an exact copy of the Car class. The only differences are that a bicycle has only two tires, has no engine, and is called a bicycle. As you might imagine, creating similar classes this way gets very ineffective the larger classes get, and the more classes an application requires. For example, what would need to be done if the garage decided to repair motorcycles as well? Expanding the example above, another class would have to be created. In fact, it would also be very similar to the Car class.\nWhat would happen if a mistake were made in the source code that implements the way that tires are accounted for? Or suppose that an adjustment needed to be made (e.g., adding another instance variable to keep track of a spare tire). In the best case, modifications to all three classes would have to be made, thereby increasing the chances of making mistakes and causing errors.\nAs discussed previously, the concept of inheritance allows us to create a superclass that can encapsulate all of the common members that one or more subclasses can share. The subclasses that are created from some superclass can be considered to be specific subtypes of the superclass.\nOne way to modify the code in the example above to utilize inheritance is to create a Vehicle superclass that defines all of the members that are shared among all types of vehicles in the application: cars, bicycle, and motorcycles. The car, bicycle, and motorcycle classes would then inherit from and become subclasses of the Vehicle class. This greatly helps to reduce code duplication. To illustrate this, here are modified classes, along with some test code, that updates the classes above and implements inheritance:\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n    def __str__(self):\n        return \"Car; \" + super().__str__()\n\n\nclass Bicycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle; \" + super().__str__()\n\n\nclass Motorcycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(b1)\nprint(m1)\nAnd here is the output of the program\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nMotorcycle; owner=Randy, tires=2, engine=True\nLook over the code above and see if it makes sense to you. Notice the default values of None for the variables tires and engine. These values are overwritten in the subclasses, depending on which subclass is initialized, as follows:\n\n\n\nClass\ntires\nengine\n\n\n\n\nVehicle\nNone\nNone\n\n\nCar\n4\nTrue\n\n\nBicycle\n2\nFalse\n\n\nMotorcycle\n2\nTrue\n\n\n\nAlso notice that the constructor of the Vehicle class (the superclass) is called in the constructor of each of the subclasses. In fact, this is the first statement in the constructors of the subclasses. That is, the initialization of a car, bicycle, and motorcycle first means to initialize a vehicle. This sets default values for the variables tires and engine. The owner of the vehicle is passed in when instantiating each of the subclasses, and is forwarded to the superclass (where the value is formally assigned). Any remaining initialization of the subclasses is done after the call to the constructor in the superclass (i.e., specific values for the variables tires and engine).\nAlso, the class output magic function __str__ also calls the matching function in the Vehicle superclass. Why? Well, it actually generates the appropriate output for any kind of vehicle (i.e., owner, number of tires, and whether or not it has an engine). The only distinguishing characteristic is the actual name of the class. Therefore, the subclasses first generate a string matching their name followed by a call to the superclass function (which generates a string containing the information specified above).\nAs a last modification, note that bicycles and motorcycles have the same number of tires. Since we can have many levels of inheritance, let’s try to add a generic Cycle class that encapsulates the attributes shared by all kinds of cycles (i.e., bicycles and motorcycles). To be clear, the application now has the following class diagram:\n\n\n\nClass diagram of Vehicle, Car, Cycle, Bicycle, and Motorcycle\n\n\n\n\n\n\n\n\nActivity\n\n\n\nImplement the Cycle class; then, modify the Bicycle and Motorcycle classes to inherit from the Cycle class.\n\n\nThe act of designing an application, particularly a large one, requires consideration of many factors that help to ensure its success. That is, there are ideas that must be considered in order to make designing an application easier. Much of the remainder of this lesson is dedicated to identifying such techniques."
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#abstraction-and-modularization",
    "href": "lessons/02 More on Objects/index.html#abstraction-and-modularization",
    "title": "02 More on Objects",
    "section": "Abstraction and Modularization",
    "text": "Abstraction and Modularization\n\n\n\n\n\n\nDefinition\n\n\n\nAbstraction is the ability to ignore the details of parts of a system in order to focus our attention at a higher level.\n\n\nThink of a Google map. When zoomed out to its default level, an entire city may be visible. Detailed street names, building structures, and so on, are invisible as they would clutter the map. Similarly, areas surrounding the city (e.g., state, region, country) are not visible. Zooming in reveals more detail of a part of the city; however, some of the surrounding detail that was present before is lost. Zooming out may further hide details, but bring in surrounding cities and towns. These zoom levels present just enough information that is required to process the map at that level.\nThe object-oriented paradigm is actually emblematic of this concept. Consider the traffic simulation application that was discussed in a previous lesson. In case you have forgotten, its goal was to model vehicle traffic in a large city for the purpose of analyzing how it manages traffic during rush hour. This kind of application would be useful in learning about traffic patterns, congestion, and so on. In fact, it could help to redesign roads, entrances to and exits from highways and interstates, the placement and timing of traffic signals, etc. As discussed, such an application may include classes for cars, pickup trucks, buses, tractor trailers, motorcycles, and so on, since all of these things contribute to the traffic in the city. We initially modeled it with the following class diagram:\n\n\n\nClass diagram for a traffic simulatioin application\n\n\nIn the simulation, the way in which cars, pickup trucks, buses, motorcycles, and so on, are implemented doesn’t matter to a city official using it to make zoning decisions. Those details are abstracted away from the user. As another example, the programmers tasked with extending the traffic simulation don’t necessarily need to know how a bus works to, say, support school zones in the simulation.\nAt its most basic level, the concept of an object represents a way of abstracting away data and operations into a single thing, the data being state and operations being behavior. To instantiate an object and use it in some programming context, there is no real need to know how some behavior is actually implemented, for example. Simply understanding the interface (i.e., how to invoke some sort of behavior) is enough. We just need to know what function to call, what parameters to pass it, and if we should expect a return value.\n\n\n\n\n\n\nDefinition\n\n\n\nModularization is the act of dividing a whole into well-defined parts that can be built and examined separately.\n\n\nIt is important to note, however, that the parts typically interact and must do so in well-defined ways. This facilitates reasoning about and maintenance of the application. In the traffic simulation example, the act of designing various classes to best represent the components of the application inherently demonstrates modularization.\nOften, abstraction and modularization go hand-in-hand. In a sense, modularization results in different levels of abstraction throughout some application. Moreover, the goal of setting levels of abstraction in an application (for example, to make maintenance easier and more manageable) motivates modularization"
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#polymorphism",
    "href": "lessons/02 More on Objects/index.html#polymorphism",
    "title": "02 More on Objects",
    "section": "Polymorphism",
    "text": "Polymorphism\nLet’s go back to the mechanic’s garage problem that was used earlier. Notice that all of the classes involved have their own __str__ function. When we execute a statement such as print(b1), which specific __str__ function is executed?\n\n\n\n\n\n\nDefinition\n\n\n\nMethod lookup solves the problem of finding the right method to call in a class hierarchy. The idea of having multiple methods with the same name in multiple classes is called polymorphism.\n\n\nAt first, it may seem confusing to have multiple functions in different classes with the same name; however, it turns out to be a very handy feature of object-oriented programming. Let’s answer the question that was initially posed: when we execute a statement such as print(b1), which specific __str__ function is executed? The variable b1 is a bicycle. Therefore, if an __str__ function exists in the Bicycle class, then it is executed. Indeed, one exists in the class. In fact, it contains the following single statement:\nreturn \"Bicycle; \" + super().__str__()\nNote that the function also calls the __str__ function in the Cycle class via the right-hand part of the statement: super().__str__(). The entire string cannot be returned until __str__ in the Cycle class has finished execution. It, too, contains only a single statement:\nreturn super().__str__()\nClearly, it calls the __str__ function in the Vehicle class, which returns a string containing the owner of the vehicle, its number of tires, and whether it has an engine or not:\n return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\nIn the end, all three __str__ output functions are executed with the statement print(b1). What about the statement print(c1)? In a similar manner, we see that the __str__ function in the Car class is executed first (since c1 is an instance of the Car class). This function calls its matching function in the Vehicle class (in order to actually produce the string containing the car’s owner, number of tires, and whether it has an engine or not).\nIn both of these examples, the function that is called is the one located in the object reference’s defining class. That is, since b1 is a bicycle, then the function in the Bicycle class is called. Similarly, since c1 is a car, then the function in the Car class is called. The fact that there may be chained calls to matching functions in superclasses is just coincidence (however, it is intentional in order to produce the proper output).\nLet’s take a look at a slightly modified version of the previous example. First, the classes:\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"Vehicle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n\nclass Cycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n\n\nclass Bicycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle!\"\n\n\nclass Motorcycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\n# main\nc1 = Car(\"John\")\nc2 = Cycle(\"Samantha\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(c2)\nprint(b1)\nprint(m1)\nThis example has the same classes as the previous one. However, the __str__ functions have been changed in various ways.\n\n\n\n\n\n\nActivity\n\n\n\nGiven the discussion above about method lookup, can you explain what the print statements in the main part of the program will produce?\n\n\nMethod lookup is essentially a simple concept. If a specified function is not found in a class, then a search for the matching function is performed in the superclass. In fact, method lookup works by continuously trying to find a matching function in the superclass hierarchy until one is found. If one is not found, then an error occurs.\nPolymorphism is a powerful concept. It allows us to specify a function at a superclass level (including any desired implementation), and then to overwrite it at lower levels of the class hierarchy (i.e., in subclasses). Consider this a way to specialize or refine behaviors defined in superclasses.\nLet’s look at an example of how this can be leveraged to produce efficient programs. Consider a scenario in which you want to write a program that can draw basic shapes (e.g., a rectangle). Such a program can be designed by creating a rectangle class that stores its length and width in instance variables, and has a draw function that produces a representation of that shape (for now, just using characters that can be found on a keyboard). A simple class diagram for this could be the following:\n\n\n\nClass diagram of the Rectangle class\n\n\nAnd here’s one possible method of implementing the class\nclass Rectangle:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\nr1 = Rectangle(10, 4)\nr1.draw()\nLastly, here’s the output produced by the program above:\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\nSure enough, we asked for a rectangle that is 10 units long by 4 units high. And that’s what we got! Now suppose that we want to expand the program to be able to accommodate squares. Squares are very similar to rectangles except that their length and width are always equal. Considering what we now know about inheritance and polymorphism, we could create a generic shape class that both squares and rectangles could inherit from.\nHere’s an updated version that implements this:\nclass Shape:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, l, w):\n        super().__init__(l, w)\n\n\nclass Square(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\nThe Square and Rectangle classes are subclasses of the Shape class. Note that they have no instance variables or functions unique to them. That is, they inherit everything from their superclass. The only difference between the two is that the constructor of the Square class takes only one argument, while the constructor of the Rectangle class takes two arguments. Within their individual implementations, they both call the constructor of the Shape class.\nWhen we want to draw a square or rectangle, we call the draw function. Method lookup makes it easy to see that the draw function in the Shape class will be executed. Why? Because the Square and Rectangle classes don’t have a draw function of their own, but their superclass (the Shape class) does.\nSince one of the benefits of inheritance is to increase code reuse and to ease expansion and application feature enhancement, let’s do precisely that by adding the ability to create and draw triangles. To simplify this, let’s just consider right-angled isosceles triangles (i.e., the two sides making up the right angle are of equal length). Since triangles are shapes too, it makes sense to make them a subclass of the Shape class, yielding the following modified class diagram:\n\n\n\nClass diagram of Shape, Rectangle, Square and Triangle\n\n\nNote the specification of the draw function in the triangle class. The shape of a triangle is different from that of a square or a rectangle, and the process of drawing that shape is therefore different. Polymorphism allows us to create another function, also called draw, but specifically for triangles. This overwrites the draw function specified in the Shape class, and effectively specializes the draw behavior for a triangle. This version of draw would only be executed on an object reference of the type Triangle.\nHere is the new Triangle class, along with an updated main part of the program (note that the rest of the program that defines the other classes remains unchanged):\nclass Triangle(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * (self.width - i))\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\nprint()\n\nt1 = Triangle(7)\nt1.draw()\nThe output of this modified program is as follows:\n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n\n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n\n* * * * * * * \n* * * * * *\n* * * * *\n* * * *\n* * *\n* *\n* \nPay close attention to the following statements in the draw function of the Triangle class:\nfor i in range(self.width):\n    print(\"* \" * (self.width - i))\nThe variable i iterates from 0 through the width of the triangle (minus one). Since the triangle is seven units long, then i iterates from 0 through 6 (exactly seven times). The first time in the for loop, the variable i is equal to 0. Therefore, the number of asterisks displayed is 7 – 0 = 7. The next time through the loop, i is equal to 1, and 7 – 1 = 6 asterisks are displayed. This continues until the last time through the loop, where i is equal to 6 and 7 – 6 = 1 asterisk is displayed.\n\nAcivity: Zooland\nNow that you have an idea about polymorphism and method lookup, let’s look at a hypothetical example in which we’ll be more concerned about the placement of the polymorphic methods rather than their actual implementation.\nSuppose that you are writing a program to model (i.e., programmatically represent) the types of animals that are in a zoo. Such a situation would easily lend itself to inheritance, since there are multiple animals that are similar in nature (and could therefore inherit similar traits from a superclass). In fact, a possible class diagram for such a program is shown on the next page.\nThe class diagram shows how a variety of animals are related. All animals move; therefore, a move function is defined in the topmost Animal class. That particular version of move is implemented as: “move in a given direction using four limbs, all of which are in contact with the ground at some point.”\nOf course this definition of move is not accurate for some of the animals that are in the class diagram. The objective of this activity is to place one of the following alternate versions of move in the appropriate classes, such that all animals move in their proper way. Since the motivation behind inheritance is primarily to reduce code duplication, the goal is to place as few move functions in the hierarchy as possible. Here are the alternate versions of the move function:\n\nMove in a given direction using four limbs, all of which are in contact with the ground at some point (note that this is the version in the animal class);\nMove in a given direction using two limbs, both of which are in contact with the ground at some point;\nMove in a given direction using wings or wing-like body parts;\nMove in a given direction using six or more limbs, all of which are in contact with the ground at some point;\nMove in a given direction using fins or fin-like body parts; and\nMove in a given direction by slithering on the ground.\n\nRemember that the higher up a function is in the inheritance hierarchy, the more classes it can be applied to. In addition, it is possible that a better result is obtained by removing or changing the version of move currently in the Animal class to another version. Note that in cases where an animal could potentially implement more than one of the given versions of move, assume that the animal only uses the more dominant version. For example, while an eagle could walk on two limbs, it predominantly flies through the air to move; therefore, use version (3).\n\n\n\nAnimal class diagram"
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#multiple-inheritance",
    "href": "lessons/02 More on Objects/index.html#multiple-inheritance",
    "title": "02 More on Objects",
    "section": "Multiple Inheritance",
    "text": "Multiple Inheritance\nIn the previous lesson on the object-oriented paradigm, the concept of multiple inheritance (and how it differs from single inheritance) was briefly discussed. In this lesson, we have only looked at cases where a class only inherits traits from a single superclass. Most programming languages only support single inheritance; however, there are cases where it would be advantageous to support inheriting traits from more than one superclass.\n\n\n\n\n\n\nDefintion\n\n\n\nSingle inheritance is when a class inherits traits from a single superclass. Multiple inheritance is when a class inherits traits from two or more superclasses. Some languages only support single inheritance while others (such as Python) support multiple inheritance.\n\n\nTo illustrate this again, consider the example used previously of a grocery store’s items. A banana, for example, is a fruit. Therefore, it may inherit traits such as type and country of origin from a Fruit superclass. However, in the context of a grocery store, a banana is also an item for sale. Such a sale item may have a price, an inventory, and a shelf location, for example. Inheriting from both a Fruit superclass and a SaleItem superclass would then be useful in implementing the point-of-sale system for a grocery store. Here’s a class diagram that illustrates this:\n\n\n\nExample of a Multiple Inheritance Class Diagram\n\n\nTo declare a class as having more than one superclass, we simply put the names of its superclasses (each separated by a comma) in the parentheses following its class name. Here’s an example with the banana class:\nclass Banana(Fruit, SaleItem):\n    ...\nMethod lookup in the context of multiple inheritance raises an interesting question: which function is called if more than one superclass has a function with the same name? For example, the Banana class does not have the __str__ function as shown in the class diagram; however, both the Fruit and SaleItem classes do. So which of the two __str__ functions is executed supposing some print statement on an object reference of the Banana class is executed?\nSince the Banana class has no __str__ function, then the normal behavior is to find the matching function in the superclass. However, the banana class has two superclasses. With multiple inheritance, method lookup is carried out in the order in which the superclasses are listed in the class arguments. In the Banana class header shown above, for example, the matching function would first be searched for in the Fruit class since it is the first superclass listed. If found (which it clearly is), it is executed; if not, then the matching function would be searched for in the SaleItem class. If found, it would be executed; if not, an error would occur (since the method would never have been found)."
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#abstract-methods",
    "href": "lessons/02 More on Objects/index.html#abstract-methods",
    "title": "02 More on Objects",
    "section": "Abstract Methods",
    "text": "Abstract Methods\nOne of the benefits of the object-oriented paradigm in programming is that it easily allows for more than one programmer to be involved in the implementation of a system. The implementation is often divided according to classes (e.g., one team of programmers works on one class while another team deals with another class). In these cases, it is important to include measures that allow any programmer to know the expectations of each class. One of the measures that helps with this is the idea of abstract methods.\nConsider the animal hierarchy that was discussed earlier in this lesson. Suppose that one team was tasked with the design of the Animal class, and another with the design of various classes at the bottom of the hierarchy. Generally, it is good programming practice to put the members that all (or many of) the classes will use higher up in the hierarchy. Suppose that the project required a function to represent the way animals communicate (i.e., sound and motion cues). We know that all animals communicate in one way or another; however, there is no general way that applies to the majority of the animals. In this scenario, it is beneficial to use an abstract method.\n\n\n\n\n\n\nDefintion\n\n\n\nAn abstract method in a class is a way of promising that any subclasses of some superclass will provide implementation details for that method.\n\n\nIn the communication example above, the Animal class has no general way of implementing some sort of communicate function. Since all animals communicate, it is imperative that all subclasses provide an explicit implementation for the communicate function.\nIn Python, a method in a class is made abstract by providing a single statement that generates an error noting that a subclass has not implemented the abstract method. In Python (as in many other object- oriented programming languages), errors can be raised or thrown to alert the user of some sort of problem. In Java, for example, errors (actually called exceptions) are thrown. In Python, errors are raised. This will be discussed thoroughly in a future lesson. For now, it is sufficient to note that abstract methods can raise an error known as a NotImplementedError. Should a subclass not implement a function defined as abstract in the superclass, and an object reference of the subclass tries to call it, the error will be raised. This terminates the program.\nHere is an example of a simple Animal class (with the abstract method communicate) and a Bird subclass. The Bird subclass does not implement the abstract method in this example:\nclass Animal:\n\n    def __init__(self):\n        \"\"\" Constructs a new Animal \"\"\"\n\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n        raise NotImplementedError(\"Abstract method communicate not implemented in subclass!\")\n\n\nclass Bird(Animal):\n\n    def __init__(self):\n        \"\"\" Constructs a new Bird \"\"\"\n\nb = Bird()\nb.communicate()\nThe functions above simply have comments instead of any actual implementation; however, they can still be used to understand the concept. The Animal class has a constructor and an abstract function called communicate. Making that function abstract is a way of enforcing that all subclasses have an actual implementation of it (instead of, for example, hoping that whoever is working on that class remembers to implement it). Note the only statement in the function:\nraise NotImplementedError(\"Abstract method...\")\nThe Bird class has not implemented the communicate function in this example. Therefore, the statement b.communicate() causes a NotImplementedError to be raised:\nTraceback (most recent call last):\n    File \"...\\02 More on Objects\\code\\abstract1.py\", line 14, in &lt;module&gt;\n        b.communicate()\n    File \"...\\02 More on Objects\\code\\abstract1.py\", line 7, in communicate\n        raise NotImplementedError(\"Abstract method communicate not implemented in subclass!\")\n    NotImplementedError: Abstract method communicate not implemented in subclass!\nBut why is the error raised? It all comes down to method lookup. Since the function is not defined in the Bird subclass, then it is searched for in its superclass (i.e., the Animal class). Of course, it is found there; however, it only contains the statement that raises the error. And so the error is raised!\nTo show that actually implementing the communicate function in the Bird class works, here’s a modification of the above program:\nclass Animal:\n\n    def __init__(self):\n        \"\"\" Constructs a new Animal \"\"\"\n\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n        raise NotImplementedError(\"Abstract method communicate not implemented in subclass!\")\n\n\nclass Bird(Animal):\n\n    def __init__(self):\n        \"\"\" Constructs a new Bird \"\"\"\n\n    def communicate(self):\n        \"\"\" How a bird communicates \"\"\"\n        print(\"A Bird communicates!\")\n\n\nb = Bird()\nb.communicate()\nThe output of the program is the single line:\n     A Bird communicates!\nNote the comments in the constructors of the Animal and Bird classes. These functions have no actual code. You may be wondering why Python doesn’t generate the error: IndentationError: expected an indented block. Recall that using the keyword pass is an easy way of stubbing out functions whose details will be provided at a later time. Python considers comments specified with three quotes (single or double) to be a valid statement. Therefore, another way to stub out a function (without using the keyword pass) is to provide such a comment.\nAnother way of implementing an abstract method is by making use of the Abstract Base Class (abc) library that is packaged with Python. When imported, a method can be marked as abstract in the same way that one can be marked as an accessor or mutator. The difference is the decorator used to mark the function: @abc.abstractmethod. This method ensures that a TypeError will be raised immediately upon the instantiation of a subclass if the abstract method is not implemented in the subclass. Note that the following statement must be placed at the top of the class (i.e., after the class signature) in order for this method to work:\n(metaclass = abc.ABCMeta)\nHere’s an example of a modified Animal class that implements this way of including abstract methods:\nimport abc\n\nclass Animal(metaclass = abc.ABCMeta):\n\n    def __init__(self):\n        \"\"\" Constructs a new Animal \"\"\"\n\n    @abc.abstractmethod\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n\n\nclass Bird(Animal):\n\n    def __init__(self):\n        \"\"\" Constructs a new Bird \"\"\"\n\n\nb = Bird()\nb.communicate()\nNote the differences. First, the abc library is imported. Second, the communicate method is marked as abstract via @abc.abstractmethod. Third, the class has the following statement with its signature:\n(metaclass = abc.ABCMeta)\nWhen the variable b is instantiated as a new object of the Bird class, the following error occurs:\nTraceback (most recent call last):\n    File \"...\\02 More on Objects\\code\\abstract3.py\", line 17, in&lt;module&gt;\n         b = Bird()\n    TypeError: Can't instantiate abstract class Bird with abstract methods communicate\nTo show that actually implementing the abstract method in the Bird subclass works with this way of including abstract methods, here is working source code:\nimport abc\nclass Animal(metaclass = abc.ABCMeta):\n\n    def __init__(self):\n        \"\"\" Constructs a new Animal \"\"\"\n\n    @abc.abstractmethod\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n\n\nclass Bird(Animal):\n\n    def __init__(self):\n        \"\"\" Constructs a new Bird \"\"\"\n\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n        print(\"A Bird communicates!\")\n\n\nb = Bird()\nb.communicate()\nThe output of the program is the single line:\nA Bird communicates!\nIn standard practice, the first method is usually preferred. The main reason for this is that the second is not particularly Pythonic. Python prides itself in being dynamic and obvious. That is, it is quite readable that the communicate method defined in the Animal class must be implemented in the Bird subclass because it raises an error if it is called. On the other hand, the first method requires the unimplemented function to actually be called by an object reference of the first class before an error is raised. The second method immediately raises an error when an object of the subclass that doesn’t implement the abstract method is instantiated. So in the end, take your pick."
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#abstract-classes",
    "href": "lessons/02 More on Objects/index.html#abstract-classes",
    "title": "02 More on Objects",
    "section": "Abstract Classes",
    "text": "Abstract Classes\nRecall the Zooland activity discussed earlier. Although the Animal class exists and can be instantiated, what kind of animal would such an instance imply? That is, what kind of animal would it be? In fact, it could be any animal. The intended behavior is most likely to only allow the creation of instances of the various animals at the bottom of the hierarchy. For example, instantiating an Ostrich, Dolphin, and Wolf should be allowed. However, instantiating a Bird, Mammal, or Terrestrial (Mammal) should not since they aren’t specific enough and really describe groups or types of animals.\nInstantiating any class in the hierarchy can create confusion because it could potentially allow instances of objects that were not planned in the design. We can restrict the instantiation of the Animal class, for example, by making it abstract. That way, no one can just instantiate an Animal object.\n\n\n\n\n\n\nDefintion\n\n\n\nAbstract classes are classes designed solely to be used as superclasses and never to be instantiated.\n\n\nEnsuring that the subclasses of abstract classes are not abstract means that they can be instantiated.\nIn Python, the only way to make a class abstract is to use the Abstract Base Class method discussed above. To prevent the class from actually being instantiated, at least one of its methods must be made abstract. The following Animal class, for example, cannot be instantiated because its communicate method is abstract:\nimport abc\nclass Animal(metaclass = abc.ABCMeta):\n\n    def __init__(self):\n        \"\"\" Constructs a new Animal \"\"\"\n\n    @abc.abstractmethod\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n\n\nclass Bird(Animal):\n\n    def __init__(self):\n        \"\"\" Constructs a new Bird \"\"\"\n\n    def communicate(self):\n        \"\"\" How an animal communicates \"\"\"\n        print(\"A Bird communicates!\")\n\na = Animal()         \nNote that the program above is the same as before, except that the main part of the program has been changed to attempt to declare an instance of the Animal class. Here’s the output:\nTraceback (most recent call last):\n    File \"...\\lessons\\02 More on Objects\\code\\abstract5.py\", line 21, in &lt;module&gt;\n        a = Animal()\n    TypeError: Can't instantiate abstract class Animal with abstract methods communicate\nMake sure that you understand that using the abc library to implement abstract methods means that the entire class is also abstract. However, it is the only way to actually make an entire class abstract. So which method should you choose? If you want to make entire classes abstract, then you must use the second method (i.e., using the abc library). If you just want to make one or more functions in a class abstract but not the entire class, then use the first method.\n\n\n\n\n\n\nDid you know?\n\n\n\nAs discussed above, abstract classes cannot be instantiated, and are instead only used as superclasses to define state and behavior that can be inherited by subclasses. Concrete classes are those classes that can be instantiated."
  },
  {
    "objectID": "lessons/02 More on Objects/index.html#coupling-and-cohesion",
    "href": "lessons/02 More on Objects/index.html#coupling-and-cohesion",
    "title": "02 More on Objects",
    "section": "Coupling and Cohesion",
    "text": "Coupling and Cohesion\nSo far in this lesson, the concepts that have been discussed all help in designing code. In particular, you may have noticed that they help reason about and design large projects involving many programmers. The kinds of projects that you will likely work on in an educational setting are usually small in comparison to the kinds of projects that professionals work on in industry. These large projects require careful consideration when designing them, programming them, and later testing them, so that they are manageable and ultimately produce a solution that solves some original problem.\nThe rest of this lesson will focus on a few more topics that help address the design of applications. The first looks at the connections between separate units of a program.\n\n\n\n\n\n\nDefinition\n\n\n\nA unit is any reasonably self-contained component of a program.\n\n\nFor example, a class can be considered a unit. But at another level of abstraction, so can a function. In fact, the function can be considered as zooming in on a class. Zooming out of a class may reveal several classes, all contained within some library. The library can also be considered a unit, just at another level of abstraction.\n\n\n\n\n\n\nDefinition\n\n\n\nCoupling refers to links between the separate units of a program.\n\n\nIf two classes depend closely on one another, we say that they are tightly coupled. Similarly, if two methods depend closely on one another, they are tightly coupled. Two units that do not depend closely on one another are loosely coupled. When designing applications, we aim for loosely coupled units, or generally just loose coupling. Why? Because it makes it possible to understand one unit without having to understand others. In the end, it just makes things simpler. For example, we can change one class with little to no effect on other classes. This increases maintainability. We try to avoid tight coupling, because changes to a unit that is tightly coupled with one or more other units can cascade and result in a chain of additional changes to the other units.\n\n\n\n\n\n\nDefinition\n\n\n\nCohesion refers to the number and diversity of tasks that a single unit is responsible for.\n\n\nIf a unit is responsible for a single task, we say that it has high cohesion. If a unit is responsible for many tasks, we say that it has low cohesion. When designing applications, we aim for high cohesion. The more simple and lean a unit is, the easier it is to understand what it does. It’s just that much easier to reason about and maintain.\nGenerally, applications that are highly cohesive often make it easy to reuse units in order to reduce code duplication. Low cohesion implies that units perform multiple tasks and have no clear identity. So what does this mean specifically in terms of application design? At the class level: classes should represent one single, well defined entity; and at the function level: a function should be responsible for one well defined task.\nDesigning applications with loose coupling and high cohesion helps with localizing change. When change is needed, as few units as possible should be affected. In fact, we can use the concepts of coupling and cohesion to answer the questions, “How long should a class be?” and “How long should a function be?” Simply put, a function is too long if it does more than one logical task, and a class is too complex if it represents more than one logical entity. Of course, these are guidelines; the real world is often a bit more complicated."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html",
    "href": "lessons/01 More on Data Structures/index.html",
    "title": "01 More On Data Structures",
    "section": "",
    "text": "So far, you have been introduced to various elementary and high level data structures: arrays, linked lists, stacks, queues, and binary trees. Specific to Python, you have used lists (similar to arrays) in your programs. In this lesson, we will discuss some powerful functions that work with lists and introduce several new data structures."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#introduction",
    "href": "lessons/01 More on Data Structures/index.html#introduction",
    "title": "01 More On Data Structures",
    "section": "",
    "text": "So far, you have been introduced to various elementary and high level data structures: arrays, linked lists, stacks, queues, and binary trees. Specific to Python, you have used lists (similar to arrays) in your programs. In this lesson, we will discuss some powerful functions that work with lists and introduce several new data structures."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#useful-list-functions",
    "href": "lessons/01 More on Data Structures/index.html#useful-list-functions",
    "title": "01 More On Data Structures",
    "section": "2 Useful List Functions",
    "text": "2 Useful List Functions\nAs you have seen, Python lists are extremely useful data structures. In the first Python lesson, you were introduced to several list functions that, for example, reverse a list, sort a list, etc. In this lesson, we will cover several more powerful built-in functions that are quite useful when used with lists.\nThe filter function returns an iterator that contains a new list consisting of only the items within an existing list for which some user-defined function is true. The user-defined function can be anything that evaluates an input in the existing list and returns true or false. The format for the filter function is as follows:\nfilter(function, mylist)\nThe parameter function represents the name of the function that will evaluate each item in the existing list. The parameter mylist is, of course, the existing list of items to evaluate.\nAn “iterator” is an object that contains a list. We can use iterators to operate on a list of values. To convert this iterator into a list object, that would expose the list it contains, we should wrap the call to filter with a list constructor:\nlist(filter(function, mylist))\nThis converts the returned iterator into a list that we can print directly.\nSuppose, for example, that you want to find all of the multiples of three or five that are less than or equal to 30 and make a list of them. Here’s one way to do this:\nmultiples = []\n\nfor i in range(3, 31):\n    if (i % 3 == 0 or i % 5 == 0):\n        multiples.append(i)\nHowever, here’s how it could be done with the filter function:\ndef f(x):\n    return (x % 3 == 0 or x % 5 == 0)\n\nmultiples = list(filter(f, range(3, 31)))\nBoth of these methods generate the following list:\n[3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24, 25, 27, 30]\nThe map function returns an iterator that contains a new list consisting of the return values generated by a user-defined function on each item in an existing list. The user-defined function is called for each item in the existing list; the return values form the new list. The format for the map function is as follows:\nmap(function, mylist)\nLike the filter function, we need to wrap the call to map inside of a list constructor call:\nlist(map(function, mylist))\nThe parameters are the same as specified for the filter function. Suppose, for example, that you want to square each item in a list. Here’s one way to do this:\nsquares = list(range(1, 10))\n\nfor i in range(len(squares)):\n    squares[i] *= squares[i]\nAlthough the snippet of code above does modify the existing list, it could be easily changed if needed. Here’s how it could be done with the map function:\ndef f(x):\n    return x * x\n\nsquares = list(map(f, range(1, 10)))\nBoth methods produce the following list:\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\nLastly, the reduce function processes the elements in a list through a user-defined function and returns a single value. The function works by first processing the first two items of the list. The result of this is processed by the function, along with the next item in the list. This continues for all of the remaining items in the list. The format for the reduce function is as follows:\nreduce(function, list)\nAgain, the parameters are the same as specified for the previous functions. Suppose, for example, that you want to compute the factorial of 10. Here’s one way to do this:\nfact = 1\nfor i in range(1, 11):\n    fact *= i\nFinally, here’s how to do it with the reduce function. Note that the reduce function comes from the functools module that is part of Python. This means we need to import the function from that module before we can use it:\nfrom functools import reduce\ndef f(x, y):\n    return x * y\n\nfact = reduce(f, range(1, 11))\nBoth methods calculate the factorial of 10 (which is 3628800). The following table summarizes the list functions discussed above:\n\n\n\n\n\n\n\n\n\nFunction\nPurpose\nSyntax\nReturns\n\n\n\n\nfilter\nSelect list elements using a function\nfilter(function, list)\niterator\n\n\nmap\nApply a function to every list element\nmap(function, list)\niterator\n\n\nreduce\nReduce a list to a single value using a function\nreduce(function, list)\nvalue"
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#list-comprehensions",
    "href": "lessons/01 More on Data Structures/index.html#list-comprehensions",
    "title": "01 More On Data Structures",
    "section": "3 List Comprehensions",
    "text": "3 List Comprehensions\nConsider the simple problem of creating a list of the cubes of the integers 0, 1, 2, etc, up to 9 (i.e., 0, 1, 8, 27, 64, …, 729).\n\n\n\n\n\n\nPractice\n\n\n\nTry to write a snippet of Python code that accomplishes the above before continuing.\n\n\nAnother way uses a concept known as list comprehensions.\nA list comprehension provides a simple, concise way of creating lists (even complex ones). The most common use of this concept creates a list where each element is the result of some operation or expression applied to each element of another list.\nHere’s an example that does the same thing as the snippet of code above:\ncubes = [x * x * x for x in range(10)]\nYes, it’s a single statement! A list comprehension uses the for loop to generate or to iterate through the items of a sequence and applies some operation or expression to each of those items. In the statement above, the generated sequence is the range of values from 0 through 9. The expression that is applied to each of the elements in the generated sequence is x * x * x (i.e., it cubes each element). The result is a new list of the cubes of the elements in the generated sequence (0 through 9):\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\nThe list comprehension can be read in English as,\n\nthe variable cubed is to be a list that contains some x cubed for each x in the range 0 through 9.\n\nIn fact, we can map the English version to the Python statement:\n[insert table]\nMinimally, a list comprehension consists of brackets containing an expression (e.g., x * x * x) followed by a for-loop. Additional for-loops or even if-statements can be chained after the first for-loop. The resulting list is an evaluation of the expression in the context of the for-loops and if-statements that follow it. Here’s a seemingly convoluted example:\nsums = [x + y for x in [1, 2, 3] for y in [3, 1, 4] if x != y]\nThe output of this statement is:\n[4, 5, 5, 3, 6, 4, 7]\nThis statement generates a list of the sums of the pairs that can be formed by combining a single element from the first list [1, 2, 3] with a single element from the second list [3, 1, 4], so long as the elements differ (i.e., if x != y). The elements of each list are processed from left-to-right. The first sum is calculated by adding the first element of the first list to the first element of the second list (1 + 3 = 4). The second sum is calculated by adding the first element of the first list to the third element of the second list (1 + 4 = 5). Why the third element and not the second? Because this would mean that both elements have the same value (1). The if statement ensures that sums will only be produced if the list elements differ.\nHere’s another (similar) example of list comprehension:\npairs = [[x, y] for x in [1, 2, 3] for y in [3, 1, 4] if x &lt; y]\nThe output of this statement is:\n[[1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nThis statement generates a list of the pairs that can be formed by combining a single element from the first list ([1, 2, 3]) with a single element from the second list ([3, 1, 4]), so long as the element from the first list is less than the element from the second list. Again, the list elements are processed from left-to-right. It is similar to the previous statement; however, instead of generating a list of sums, a list of pairs of elements is generated. In fact, it’s a list of lists! The enclosed sublists are composed of only two elements each.\nReally cool things can be done with list comprehension. For example, here’s a neat way to compute pi to various precisions from two through eight digits:\nfrom math import pi\n\npi_digits = [round(pi, n) for n in range(2, 9)]\nAnd here’s the output:\n[3.14, 3.142, 3.1416, 3.14159, 3.141593, 3.1415927, 3.14159265]\nThe function round does what you expect it to do: it rounds the value specified in the first parameter to a precision specified in the second parameter. For example, the expression round(pi, 3) rounds pi to three digits to the right of the decimal point (i.e., 3.142)."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#sets",
    "href": "lessons/01 More on Data Structures/index.html#sets",
    "title": "01 More On Data Structures",
    "section": "4 Sets",
    "text": "4 Sets\nIn Python, a set is just another type of sequence. The mathematical definition of a set is an unordered collection of unique elements. That is, a set is basically just a list with no duplicates.\n\n\n\n\n\n\nDefinition\n\n\n\nA set is a type of Python sequence that contains an unordered collection of unique values.\n\n\nSince sets are mathematically defined, they support mathematical operations such as union, intersection, and difference. Defining a set can be done in several ways. The first is to formally define one, very much like you would define a list. However, instead of using square brackets, we use curly braces:\na = { 1, 2, 3, 4, 5 }\nb = { 3, 4, 5, 6, 7 }\nThese Python statements declare and initialize two sets, a and b. Another way to create a set is to do so from some other sequence (such as a list):\nc = [ 3, 1, 4, 1, 5, 9 ]\nd = set(c)\nThe list c is used as input to create the set d. The set d will only have one instance of any duplicated element in the list c; therefore, the value of the set d is as follows:\n{1, 3, 4, 5, 9}\nNote that the element 1 appears only once in the set d. In addition, the set is unordered; that is, its elements don’t necessarily have to be in the same order as those in the list.\nA set can even be created from a string (since a string is a sequence):\ne = set(\"sweet\") \nThe value of the set e is as follows:\n{'s', 't', 'w', 'e'}\nAgain, note that the elements of this set are unique. To illustrate the set operations (union, intersection, and difference), we will use the sets a and b defined above. The union of the sets a and b represents the elements in either a or b. The Python expression for this is written as a | b.\nIts output is the following set:\n{1, 2, 3, 4, 5, 6, 7}\nThese elements are all of the unique elements in a or b. Similarly, the intersection of the sets a and b represents the elements in both a and b. The Python expression for this is written as a & b. Its output is the following set:\n{3, 4, 5}\nThese elements are the only unique elements in both a and b. Lastly, the difference of the sets a and b represents the elements in a but not in b. The Python expression for this is written as a – b. Its output is the following set:\n{1, 2}\nThe difference operation can be thought of as a subtraction of the set b from the set a. All elements in both a and b are removed. The remaining elements in a make up the resulting set. Any additional elements in b that are not in a are ignored."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#dictionaries",
    "href": "lessons/01 More on Data Structures/index.html#dictionaries",
    "title": "01 More On Data Structures",
    "section": "5 Dictionaries",
    "text": "5 Dictionaries\nA dictionary is perhaps one of the most powerful data structures at our disposal in Python. As you have seen, sequences (like lists) are indexed by a range of numbers (i.e., the first element is placed at index 0, the second element is placed at index 1, and so on).\n\n\n\n\n\n\nDefinition\n\n\n\nA dictionary is a data structure whose elements are indexed by unique keys. A key is just an unchangeable value. The elements are known as values, and are associated with the keys. That is, a single key maps to a single value. This is why we often say that dictionaries contain key-value pairs.\n\n\nTechnically, a list pairs an index (which could be called a key) with a value (the element at that index). The difference is that dictionaries permit keys to be of almost any type, so long as a key is not susceptible to change. That is, it must be immutable. For example, the integer 5, the floating point number 3.14, the string “Jones”, and the character ‘%’ are all valid keys. Note that all keys in a single dictionary must be unique (i.e., there can be no duplicate keys).\nConsider a dictionary that you are familiar with: the kind that you lookup the definitions of words in. Using such a dictionary typically involves searching for some word in order to obtain its definition. In such a dictionary, the word is the key, and its definition is the value associated with that key. You should have noticed that, to search a dictionary, the key is required. The unknown is the value that is associated with the key (a definition). In some programming languages, this type of data structure is known as an associative array.\nAnother dictionary data structure that you are probably familiar with is a phone book (although you’ve probably only used some online version and not an actual book). What are the keys in a phone book? What about the values? Clearly, a name is the key (e.g., Bob Jones). The values associated with the keys are records that contain an address and a phone number. Certainly, such records can be represented as long strings (perhaps even with newlines). But we may also wish to represent the records as objects of some PersonInfo class!\nDictionaries are created similarly to sets (using braces). The difference is that key-value pairs are specified in the format key: value. Here’s an example of a dictionary with strings representing last names as the keys and integers representing office numbers as the values:\noffices = { \"Jones\": 247, \"Smith\": 121, \"Kennedy\": 108 } \nThis creates a dictionary with the following key-value pairs (in no particular order):\n\n\n\nLast Name\nOffice Number\n\n\n\n\nJones\n247\n\n\nSmith\n121\n\n\nKennedy\n108\n\n\n\nThe main operations associated with a dictionary are to store some key-value pair and to retrieve a value associated with a key. Adding the new key-value pair \"Wilkerson\": 355, for example, can be added to the dictionary above as follows:\noffices[\"Wilkerson\"] = 355\nThe dictionary now has the following key-value pairs (in no particular order):\n\n\n\nLast Name\nOffice Number\n\n\n\n\nJones\n247\n\n\nSmith\n121\n\n\nKennedy\n108\n\n\nWilkerson\n355\n\n\n\nRetrieving a value matching the key \"Smith\", for example, can be done as follows:\nloc = offices[\"Smith\"]\nThe value of the variable loc is therefore 121. Note that attempting to retrieve a value using a key that is not in the dictionary results in an error.\nAn existing key-value pair in the dictionary may be overwritten by simply inserting a new value with the same key. For example, suppose that Kennedy changed offices (to, say, 111). The dictionary can be updated as follows:\noffices[\"Kennedy\"] = 111\nThe dictionary now has the following key-value pairs (in no particular order):\n\n\n\nLast Name\nOffice Number\n\n\n\n\nJones\n247\n\n\nSmith\n121\n\n\nKennedy\n111\n\n\nWilkerson\n355\n\n\n\nA key-value pair can be removed from the dictionary using the del keyword as follows:\ndel offices[\"Smith\"]\nThe dictionary now has the following key-value pairs (in no particular order):\n\n\n\nLast Name\nOffice Number\n\n\n\n\nJones\n247\n\n\nKennedy\n111\n\n\nWilkerson\n355\n\n\n\nDetermining if a key is in the dictionary without actually returning the value associated with the key can be done by using the keyword in as follows:\n\"Kennedy\" in offices # true\n\"Smith\" in offices # false (since it was just removed)\n\nif (\"Smith\" in offices): # false\n    ...\nThe keys and values in a dictionary don’t have to be homogeneous; that is, they can each be of different types. For instance, the following key-value pair could be added to the dictionary:\noffices[12345] = \"abracadabra\"\nAlthough it doesn’t necessarily make sense, the dictionary now has the following key-value pairs (in no particular order):\n\n\n\nLast Name\nOffice Number\n\n\n\n\nJones\n247\n\n\nKennedy\n111\n\n\nWilkerson\n355\n\n\n12345\nabracadabra\n\n\n\nA neat way to obtain a list of all of the keys in a dictionary is to use the keys function as follows:\noffice_keys = list(offices.keys())\nThe keys function returns a “view” object that can be converted into a list by using the list constructor (similar to how we used it for the filter and map functions). The variable office_keys above then has the following value:\n['Jones', 12345, 'Wilkerson', 'Kennedy']\nThere are several ways of iterating through the values of a dictionary. One uses the keys function just described. This can be accomplished as follows:\nfor k in offices.keys():\n    print(offices[k])\nNote that we don’t need to convert the keys into a list if we are simply iterating through them. Of course, we can convert it to a list if we wanted to, but in the context above it isn’t necessary. The output of this snippet of Python code is:\n247\nabracadabra\n355\n111\nOf course, to produce a key-value pair mapping, only a small modification is required:\nfor k in offices.keys():\n    print(k, \"-&gt;\", offices[k])\nThe output of this now includes both the keys and values:\nJones -&gt; 247\n12345 -&gt; abracadabra\nWilkerson -&gt; 355\nKennedy -&gt; 111\nAnother way that Python provides to do the same thing and which produces the same output is to use the dictionary method items as follows:\nfor k, v in offices.items():\n    print(k, \"-&gt;\", v)\nThe items function returns a view object that contains pairs of values, each of which is a key-value pair in the dictionary.\nNote that k and v are used to stand for key and value. Any variable name will do (as long as it is descriptive) but these are normally used by convention with dictionaries. Using key and value (or val) as opposed to k and v would also be perfectly fine."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#dictionary-comprehensions",
    "href": "lessons/01 More on Data Structures/index.html#dictionary-comprehensions",
    "title": "01 More On Data Structures",
    "section": "6 Dictionary Comprehensions",
    "text": "6 Dictionary Comprehensions\nJust as with lists, comprehensions can be used to create dictionaries. Of course, these are known as dictionary comprehensions. Here’s one that creates a dictionary with the key-value pairs such that the values are cubes of the keys, and the keys range from 1 through 5:\ndict = {x: x ** 3 for x in range(1, 6)}\nThe created dictionary dict is therefore {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}. The key-value pairs are specified in the dictionary comprehension as x: x**3 (i.e., a key is some value x, and its associated value is x cubed). The range for the values (1 through 5) taken on by the variable x is specified as for x in range(1, 6).\n\n\n\n\n\n\nPractice\n\n\n\nTry to modify the dictionary comprehension above so that the values are stored as strings instead of integers."
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#activity-room-adventurereloaded",
    "href": "lessons/01 More on Data Structures/index.html#activity-room-adventurereloaded",
    "title": "01 More On Data Structures",
    "section": "7 Activity: Room Adventure…Reloaded",
    "text": "7 Activity: Room Adventure…Reloaded\nIn this activity, we will update the Room Adventure game that was designed in a previous RPi activity. The goal will be to replace the parallel arrays in the game with dictionaries. Such a substitution makes sense because parallel arrays associate (or map) the elements of two or more arrays by index value.\nThat is, the first element of one array is paired with the first element of another, and so on. Dictionaries are perfectly suited for this because they associate one value with another!\nRecall that parallel arrays were used to represent the following relationships:\n\nExits with exit locations (through the lists exits and exitLocations); and\nItems with item descriptions (through the lists items and itemDescriptions).\n\nExits were strings like “north” and “west”, and exit locations were rooms (instances of the class Room). Items were strings like “table” and “fireplace”, and item descriptions were strings like “It is made of oak. A golden key rests on it.” and “It is full of ashes.”\nVery quickly, we see that we can replace the lists exits and exitLocations with a single dictionary (perhaps just called exits). Suppose, for example, that an exit to the east led to some instance of a room represented by the variable r2, and an exit to the north led to some instance of a room represented by the variable r3. A dictionary that represents this could be created as follows:\nexits = {\"east\": r2, \"north\": r3} \nOf course, this supposes that the variables r2 and r3 exist.\n\n7.1 Replace the parallel lists with dictionaries\nThe first thing to do to modify our game is to remove the parallel arrays for both exits and items, and replace them with dictionaries. This must be done in the constructor of the Room class; specifically, in lines 16 through 19:\n14: def __init__(self, name): \n15:     self.name = name\n16:     self.exits = []             # list before replacement\n17:     self.exitLocations = []     # list before replacement\n18:     self.items = []             # list before replacement\n19:     self.itemDescriptions = []  # list before replacement\n20:     self.grabbables = []\n\n\n\n\n\n\nNote\n\n\n\n\nline numbers specified in this activity are valid only within the existing source code (i.e., not the one that is being modified because changes may invalidate the line numbers)\nSome comments in the source code have been removed in this activity for brevity.\n\n\n\nThe statements on lines 16 through 19 are the parallel arrays that will need to be replaced with dictionaries. The lists exits and exitLocations are paired; so are the lists items and itemDescriptions. Let’s replace them with two dictionaries instead:\ndef __init__(self, name): \n    self.name = name\n    self.exits = {}     # dictionary after replacement\n    self.items = {}     # dictionary after replacement\n    self.grabbables = []\nThere is no longer a need for matching lists since the dictionaries intrinsically match keys to values! Pay attention to the braces (as opposed to brackets).\n\n\n7.2 Remove the accessors and mutators for the deleted parallel lists\nRecall that accessors and mutators were implemented for each of a Room’s instance variables. Since the lists exitLocations and itemDescriptions were removed, their respective accessors and mutators must also be removed. The existing accessors and mutators for the instance variables exits and items remain unchanged. In fact, they will work seamlessly with the new dictionaries.\nThe accessor and mutator for the old instance variable exitLocations are located on lines 39 through 45, and must be removed from the source code:\n39: @property\n40: def exitLocations(self):\n41:     return self._exitLocations \n42:\n43: @exitLocations.setter\n44: def exitLocations(self, value): \n45:     self._exitLocations = value\nThe accessor and mutator for the old instance variable itemDescriptions are located on lines 55 through 61, and must also be removed from the source code:\n55: @property\n56: def itemDescriptions(self):\n57:     return self._itemDescriptions\n58:\n59: @itemDescriptions.setter\n60: def itemDescriptions(self, value):\n61:     self._itemDescriptions = value\n\n\n7.3 Modify the addExit and addItem functions\nThe next step is to change the addExit and addItem functions in the Room class so that they appropriately insert new exits and items into dictionaries instead of parallel lists as is currently done. First, let’s change the addExit function, which begins on line 74:\n74: def addExit(self, exit, room):\n75:     # append the exit and room to the appropriate lists \n76:     self._exits.append(exit)            # remove this line\n77:     self._exitLocations.append(room)    # remove this line\nNote how the function currently appends the exit to one list and the room to another. Let’s change this so that the exit and room are added as a key-value pair to the appropriate dictionary:\ndef addExit(self, exit, room):\n    # append the exit and room to the appropriate dictionary\n    self._exits[exit] = room    # add this line\nNow, let’s change the addItem function, which begins on line 82:\n82: def addItem(self, item, desc):\n83:     # append the item and description to the appropriate lists\n84:     self._items.append(item)            # remove this line\n85:     self._itemDescriptions.append(desc) # remove this line\nThis function is similar to the old addExit function. It appends the item to one list and the description to another. Let’s change this so that the item and description are added as a key-value pair to the appropriate dictionary:\ndef addItem(self, item, desc):\n    # append the item and description to the appropriate dictionary\n    self._items[item] = desc    # add this line\n\n\n7.4 Modify the __str__function\nIn the game, the player is continually presented with the status: location, items, exits, and inventory. This is specified in the Room class and specifically involves the bit of source code that generates the string representation of a Room. This is done in the __str__ function, which begins on line 100:\n100: def __str__(self):\n101:     # first, the room name\n102:     s = \"You are in {}.\\n\".format(self.name)\n103:\n104:     # next, the items in the room\n105:     s += \"You see: \"\n106:     for item in self.items:    # needs to be modified\n107:         s += item + \" \"\n108:     s += \"\\n\"\n109:\n110:     # next, the exits from the room\n111:     s += \"Exits: \"\n112:     for exit in self.exits:    # needs to be modified\n113:         s += exit + \" \"\n114:\n115:     return s\nThe statements that need to be changed are on lines 106 and 112. In their current form, they iterate through the two lists. The list items used to contain the items (e.g., table). Since items is now a dictionary (with the items as keys and item descriptions as values), then we must iterate through its keys! This can be done by replacing line 106 with the following statement:\nfor item in self.items.keys():\nSimilarly, The list exits used to contain the exits (e.g., south). Since exits is now a dictionary (with the exits as keys and room objects as values), then we must also iterate through its keys. This can be done by replacing line 112 with the following statement:\nfor exit in self.exits.keys():\n\n\n7.5 Modify the main part of the program\nThere are two places that need modification in the main part of the program. Both are required because the current source code refers to the old lists that have been replaced by dictionaries. The first modification occurs in the part of the source code that is executed if the verb in the action specified by the player is go (e.g., “go south”). This part of the source code begins on line 247. Note that some of the next part of the if statement is provided for clarity:\n247: if (verb == \"go\"):\n248:     # set a default response\n249:     response = \"Invalid exit.\"\n250:\n251:     # check for valid exits in the current room\n252:     for i in range(len(currentRoom.exits)):                # needs to be modified\n253:         # a valid exit is found\n254:         if (noun == currentRoom.exits[i]):                 # needs to be modified\n255:             # change the current room to the one ...\n256:             currentRoom = currentRoom.exitLocations[i]     # needs to be modified\n257:             # set the response (success)\n258:             response = \"Room changed.\"\n259:             # no need to check any more exits\n260:             break                                          # needs to be modified\n261: # the verb is: look \n262: elif (verb == \"look\"): \n263: ...\nCurrently, the algorithm iterates through the list of exits. If one matches the noun specified by the player, then the current room is changed to the matching exit location (in the parallel list). If this occurs, the break statement exits the loop (i.e., we don’t need to check for more exits since a valid one has already been found). The changes required affect the highlighted lines in the snippet of source code above. Ultimately, the part of the if statement that is executed if the verb is go should be changed to the following source code. Again, some of the next part of the if statement is provided for clarity:\n# the verb is: go \nif (verb == \"go\"):\n    # set a default response\n    response = \"Invalid exit.\"\n    \n    # check for valid exits in the current room\n    if (noun in currentRoom.exits):                 # new\n        # if one is found, change the current room ... \n        currentRoom = currentRoom.exits[noun]       # new\n        # set the response (success)\n        response = \"Room changed.\"\n\n# the verb is: look \nelif (verb == \"look\"):\n    # ...\nNote that no break statement is required because there is no enclosing loop! The second modification occurs in the part of the source code that is executed if the verb in the action specified by the player is look (e.g., “look table”). This part of the source code begins on line 261. Again, some of the next part of the if statement is provided for clarity:\n261: # the verb is: look\n262: elif (verb == \"look\"):\n263:     # set a default response\n264:     response = \"I don't see that item.\"\n265:\n266:     # check for valid items in the current room\n267:     for i in range(len(currentRoom.items)):                # needs to be modified\n268:         # a valid item is found   \n269:         if  (noun == currentRoom.items[i]):                # needs to be modified\n270:             # set the response to the item's description\n271:             response = currentRoom.itemDescriptions[i]     # needs to be modified\n272:             # no need to check any more items\n273:             break                                          # needs to be modified\n274: # the verb is: take \n275: elif (verb == \"take\"):\nAs before, the algorithm iterates through a list (of items in this case). If one matches the noun specified by the player, then the response is changed to the matching item description (in the parallel list). If this occurs, the break statement exits the loop (i.e., we don’t need to check for more items since a valid one has already been found). The changes required affect the indicated lines in the snippet of source code above. Ultimately, the part of the if statement that is executed if the verb is look should be changed to the following source code. Again, some of the next part of the if statement is provided for clarity:\n# the verb is: look \nelif (verb == \"look\"):\n    # set a default response\n    response = \"I don't see that item.\"\n\n    # check for valid items in the current room\n    if (noun in currentRoom.items):         # new\n        # if one is found, set the response to the... \n        response = currentRoom.items[noun]  # new\n\n# the verb is: take \nelif (verb == \"take\"):\nAnd that’s it!"
  },
  {
    "objectID": "lessons/01 More on Data Structures/index.html#wrapping-up-data-structures",
    "href": "lessons/01 More on Data Structures/index.html#wrapping-up-data-structures",
    "title": "01 More On Data Structures",
    "section": "8 Wrapping Up Data Structures",
    "text": "8 Wrapping Up Data Structures\nBy now, you should have a good idea of the need for data structures. Generally, programs that solve problems store and manipulate data in some way. Data structures make this possible. In this curriculum, various useful data structures were introduced. Here is a table that summarizes them:\n\n\n\n\n\n\n\nData structure\nDescription\n\n\n\n\nArray\nSimilar pieces of data store in contiguous memory locations. Data values (elements) are stored at index locations. The size of an array must be known before using one.\n\n\nLinked list\nSimilar pieces of data stored in nodes located in various memory locations. Nodes store data values and a link to the next node in memory. The list has a head (the first element) and a tail (the last element). The size of a linked list can grow or shrink as needed.\n\n\nStack\nA list-like structure where inserting and deleting is performed at one end (usually called the top of the stack). Inserting is called a push operation; deleting is called a pop operation. The last item inserted in a stack is the first item out of the stack; therefore, a stack is a LIFO (last-in, first-out) data structure.\n\n\nQueue\nA list-like structure where inserting is performed at one end (usually called the back of the queue) and deleting is performed at the other end (usually called the front of the queue). Inserting is called an enqueue operation; deleting is called a dequeue operation. The first item inserted in a queue is the first item out of the queue; therefore, a queue is FIFO (first-in, first-out) data structure.\n\n\nBinary tree\nA tree-like data structure made up of nodes that store similar pieces of data. Each node has links to (up to) two children. The binary tree has a root (the top node) and leaves (nodes at the bottom with no children). From any node, a subtree can be described such that the node is the root of that subtree.\n\n\nOrdered binary tree\nA binary tree such that the values of all children in the left subtree of each node are less than the value of the node, and the values of all children in the right subtree of each node are greater than or equal to the value of the node.\n\n\nDictionary\nAlso known as an associative array, a data structure that maps keys to values. Keys are unchangeable pieces of data; values are associated with keys (one value per key)."
  }
]