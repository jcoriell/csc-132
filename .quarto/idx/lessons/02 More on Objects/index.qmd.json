{"title":"02 More on Objects","markdown":{"yaml":{"title":"02 More on Objects"},"headingText":"Inheritance","containsRefs":false,"markdown":"\n\n\nThe last major topic that was discussed in the object-oriented paradigm was inheritance. To review, there are cases where it is advantageous to have one class (called a subclass) inherit state and behavior from another class (called a superclass). Using inheritance allows us, among many other things, to avoid excessive repetition and code duplication. This makes maintaining code much easier.\n\nAs an example, let's assume that you are writing a program to store information about the kinds of vehicles that a car mechanic's garage may deal with on a daily basis. For simplicity, suppose that the mechanic only keeps track of the number of tires that a car has (yes, there are some cars that have three tires), whether the car has a working engine, and the car's owner. In this case, the car class would need three instance variables (one for each of the mentioned attributes). It may even have a function that allows a car's information to be output in a meaningful way (i.e., it would implement a `__str__` method). Even though the class is very basic, we'll use it to make a point. Here is the source code for the `Car` class, along with some sample testing code in the main part of the program:\n\n```python\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nprint(c1)\n```\n\nOf course, the output is fairly simple to determine:\n\n```default\nCar; owner=John, tires=4, engine=True\n```\n\nNow consider the case where, one day, the mechanic's garage decides to repair bicycles as well. A very quick fix would be to create a similar class just for bicycles. In fact, here are comparisons of the `Car` and `Bicycle` classes (with a slightly modified main part of the program):\n\n```python\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Bicycle:\n\n    def __init__(self, name):\n        self.tires = 2\n        self.engine = False\n        self.owner = name\n\n    def __str__(self):\n        return \"Bicycle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\n\nprint(c1)\nprint(b1)\n```\n\nAnd here is the output of this modified program:\n\n```default\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\n```\n\nNotice the code duplication? In fact, the `Bicycle` class is almost an exact copy of the `Car` class. The only differences are that a bicycle has only two tires, has no engine, and is called a bicycle. As you might imagine, creating similar classes this way gets very ineffective the larger classes get, and the more classes an application requires. For example, what would need to be done if the garage decided to repair motorcycles as well? Expanding the example above, another class would have to be created. In fact, it would also be very similar to the `Car` class.\n\nWhat would happen if a mistake were made in the source code that implements the way that tires are accounted for? Or suppose that an adjustment needed to be made (e.g., adding another instance variable to keep track of a spare tire). In the best case, modifications to all three classes would have to be made, thereby increasing the chances of making mistakes and causing errors.\n\nAs discussed previously, the concept of inheritance allows us to create a superclass that can encapsulate all of the common members that one or more subclasses can share. The subclasses that are created from some superclass can be considered to be specific subtypes of the superclass.\n\nOne way to modify the code in the example above to utilize inheritance is to create a `Vehicle` superclass that defines all of the members that are shared among all types of vehicles in the application: cars, bicycle, and motorcycles. The car, bicycle, and motorcycle classes would then inherit from and become subclasses of the `Vehicle` class. This greatly helps to reduce code duplication. To illustrate this, here are modified classes, along with some test code, that updates the classes above and implements inheritance:\n\n```python\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n    def __str__(self):\n        return \"Car; \" + super().__str__()\n\n\nclass Bicycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle; \" + super().__str__()\n\n\nclass Motorcycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(b1)\nprint(m1)\n```\n\nAnd here is the output of the program\n\n```default\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nMotorcycle; owner=Randy, tires=2, engine=True\n```\n\nLook over the code above and see if it makes sense to you. Notice the default values of None for the variables `tires` and `engine`. These values are overwritten in the subclasses, depending on which subclass is initialized, as follows:\n\n|Class|tires|engine|\n|:----|:--|:----|\n|Vehicle|None|None|\n|Car|4|True|\n|Bicycle|2|False|\n|Motorcycle|2|True|\n\nAlso notice that the constructor of the `Vehicle` class (the superclass) is called in the constructor of each of the subclasses. In fact, this is the first statement in the constructors of the subclasses. That is, the initialization of a car, bicycle, and motorcycle first means to initialize a vehicle. This sets default values for the variables `tires` and `engine`. The owner of the vehicle is passed in when instantiating each of the subclasses, and is forwarded to the superclass (where the value is formally assigned). Any remaining initialization of the subclasses is done after the call to the constructor in the superclass (i.e., specific values for the variables `tires` and `engine`).\n\nAlso, the class output magic function `__str__` also calls the matching function in the `Vehicle` superclass. Why? Well, it actually generates the appropriate output for any kind of vehicle (i.e., owner, number of tires, and whether or not it has an engine). The only distinguishing characteristic is the actual name of the class. Therefore, the subclasses first generate a string matching their name followed by a call to the superclass function (which generates a string containing the information specified above).\n\nAs a last modification, note that bicycles and motorcycles have the same number of tires. Since we can have many levels of inheritance, let's try to add a generic `Cycle` class that encapsulates the attributes shared by all kinds of *cycles* (i.e., bicycles and motorcycles). To be clear, the application now has the following class diagram:\n\n[image]\n\n::: {.callout-tip title=\"Activity\"}\nImplement the `Cycle` class; then, modify the `Bicycle` and `Motorcycle` classes to inherit from the `Cycle` class.\n:::\n\nThe act of designing an application, particularly a large one, requires consideration of many factors that help to ensure its success. That is, there are ideas that must be considered in order to make designing an application easier. Much of the remainder of this lesson is dedicated to identifying such techniques.\n\n\n## Abstraction and Modularization\n\n::: {.callout-tip title=\"Definition\"}\n**Abstraction** is the ability to ignore the details of parts of a system in order to focus our attention at a _higher_ level.\n:::\n\nThink of a Google map. When zoomed out to its default level, an entire city may be visible. Detailed street names, building structures, and so on, are invisible as they would clutter the map. Similarly, areas surrounding the city (e.g., state, region, country) are not visible. Zooming in reveals more detail of a part of the city; however, some of the surrounding detail that was present before is lost. Zooming out may further hide details, but bring in surrounding cities and towns. These *zoom levels* present just enough information that is required to process the map at that level.\n\nThe object-oriented paradigm is actually emblematic of this concept. Consider the traffic simulation application that was discussed in a previous lesson. In case you have forgotten, its goal was to model vehicle traffic in a large city for the purpose of analyzing how it manages traffic during rush hour. This kind of application would be useful in learning about traffic patterns, congestion, and so on. In fact, it could help to redesign roads, entrances to and exits from highways and interstates, the placement and timing of traffic signals, etc. As discussed, such an application may include classes for cars, pickup trucks, buses, tractor trailers, motorcycles, and so on, since all of these things contribute to the traffic in the city. We initially modeled it with the following class diagram:\n\n[image]\n\nIn the simulation, the way in which cars, pickup trucks, buses, motorcycles, and so on, are implemented doesn't matter to a city official using it to make zoning decisions. Those details are abstracted away from the user. As another example, the programmers tasked with extending the traffic simulation don't necessarily need to know how a bus works to, say, support school zones in the simulation.\n\nAt its most basic level, the concept of an object represents a way of abstracting away data and operations into a single thing, the data being state and operations being behavior. To instantiate an object and use it in some programming context, there is no real need to know how some behavior is actually implemented, for example. Simply understanding the interface (i.e., how to invoke some sort of behavior) is enough. We just need to know what function to call, what parameters to pass it, and if we should expect a return value.\n\n::: {.callout-tip title=\"Modularization\"}\n**Modularization** is the act of dividing a whole into well-defined parts that can be built and examined separately.\n:::\n\nIt is important to note, however, that the parts typically interact and must do so in well-defined ways. This facilitates reasoning about and maintenance of the application. In the traffic simulation example, the act of designing various classes to best represent the components of the application inherently demonstrates modularization.\n\nOften, abstraction and modularization go hand-in-hand. In a sense, modularization results in different levels of abstraction throughout some application. Moreover, the goal of setting levels of abstraction in an application (for example, to make maintenance easier and more manageable) motivates modularization\n\n## Polymorphism\n\nLet's go back to the mechanic's garage problem that was used earlier. Notice that all of the classes involved have their own `__str__` function. When we execute a statement such as `print(b1)`, which specific `__str__` function is executed?\n\n::: {.callout-tip title=\"Modularization\"}\n**Method lookup** solves the problem of finding the right method to call in a class hierarchy. The idea of having multiple methods with the same name in multiple classes is called **polymorphism**.\n:::\n\nAt first, it may seem confusing to have multiple functions in different classes with the same name; however, it turns out to be a very handy feature of object-oriented programming. Let's answer the question that was initially posed: when we execute a statement such as `print(b1)`, which specific `__str__` function is executed? The variable `b1` is a bicycle. Therefore, if an `__str__` function exists in the Bicycle class, then it is executed. Indeed, one exists in the class. In fact, it contains the following single statement:\n\n```python\nreturn \"Bicycle; \" + super().__str__()\n```\n\nNote that the function also calls the `__str__` function in the `Cycle` class via the right-hand part of the statement: `super().__str__()`. The entire string cannot be returned until `__str__` in the `Cycle` class has finished execution. It, too, contains only a single statement:\n\n```python\nreturn super().__str__()\n```\n\nClearly, it calls the `__str__` function in the `Vehicle` class, which returns a string containing the owner of the vehicle, its number of tires, and whether it has an engine or not:\n\n```python\n return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n```\n\nIn the end, all three `__str__` output functions are executed with the statement `print(b1)`. What about the statement print(c1)? In a similar manner, we see that the `__str__` function in the `Car` class is executed first (since `c1` is an instance of the `Car` class). This function calls its matching function in the `Vehicle` class (in order to actually produce the string containing the car's owner, number of tires, and whether it has an engine or not).\n\nIn both of these examples, the function that is called is the one located in the object reference's defining class. That is, since `b1` is a bicycle, then the function in the Bicycle class is called. Similarly, since `c1` is a car, then the function in the `Car` class is called. The fact that there may be chained calls to matching functions in superclasses is just coincidence (however, it is intentional in order to produce the proper output).\n\nLet's take a look at a slightly modified version of the previous example. First, the classes:\n\n```python\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"Vehicle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n\nclass Cycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n\n\nclass Bicycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle!\"\n\n\nclass Motorcycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\n# main\nc1 = Car(\"John\")\nc2 = Cycle(\"Samantha\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(c2)\nprint(b1)\nprint(m1)\n```\n\nThis example has the same classes as the previous one. However, the `__str__` functions have been changed in various ways. \n\n::: {.callout-tip title=\"Activity\"}\nGiven the discussion above about method lookup, can you explain what the print statements in the main part of the program will produce?\n:::\n\nMethod lookup is essentially a simple concept. If a specified function is not found in a class, then a search for the matching function is performed in the superclass. In fact, method lookup works by continuously trying to find a matching function in the superclass hierarchy until one is found. If one is not found, then an error occurs.\n\nPolymorphism is a powerful concept. It allows us to specify a function at a superclass level (including any desired implementation), and then to overwrite it at lower levels of the class hierarchy (i.e., in subclasses). Consider this a way to specialize or refine behaviors defined in superclasses.\n\nLet's look at an example of how this can be leveraged to produce efficient programs. Consider a scenario in which you want to write a program that can draw basic shapes (e.g., a rectangle). Such a program can be designed by creating a rectangle class that stores its length and width in instance variables, and has a draw function that produces a representation of that shape (for now, just using characters that can be found on a keyboard). A simple class diagram for this could be the following:\n\n[image]\n\nAnd here's one possible method of implementing the class\n\n```python\nclass Rectangle:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\nr1 = Rectangle(10, 4)\nr1.draw()\n```\n\nLastly, here's the output produced by the program above:\n\n```default\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\n```\n\nSure enough, we asked for a rectangle that is 10 units long by 4 units high. And that's what we got! Now suppose that we want to expand the program to be able to accommodate squares. Squares are very similar to rectangles except that their length and width are always equal. Considering what we now know about inheritance and polymorphism, we could create a generic shape class that both squares and rectangles could inherit from.\n\nHere's an updated version that implements this:\n\n```python\nclass Shape:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, l, w):\n        super().__init__(l, w)\n\n\nclass Square(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\n```\n\nThe `Square` and `Rectangle` classes are subclasses of the `Shape` class. Note that they have no instance variables or functions unique to them. That is, they inherit everything from their superclass. The only difference between the two is that the constructor of the `Square` class takes only one argument, while the constructor of the `Rectangle` class takes two arguments. Within their individual implementations, they both call the constructor of the `Shape` class.\n\nWhen we want to draw a square or rectangle, we call the `draw` function. Method lookup makes it easy to see that the `draw` function in the `Shape` class will be executed. Why? Because the `Square` and `Rectangle` classes don't have a `draw` function of their own, but their superclass (the `Shape` class) does.\n\nSince one of the benefits of inheritance is to increase code reuse and to ease expansion and application feature enhancement, let's do precisely that by adding the ability to create and draw triangles. To simplify this, let's just consider right-angled isosceles triangles (i.e., the two sides making up the right angle are of equal length). Since triangles are shapes too, it makes sense to make them a subclass of the `Shape` class, yielding the following modified class diagram:\n\n[image]\n\nNote the specification of the `draw` function in the triangle class. The shape of a triangle is different from that of a square or a rectangle, and the process of drawing that shape is therefore different. Polymorphism allows us to create another function, also called `draw`, but specifically for triangles. This overwrites the `draw` function specified in the `Shape` class, and effectively specializes the draw behavior for a triangle. This version of draw would only be executed on an object reference of the type `Triangle`.\n\nHere is the new `Triangle` class, along with an updated main part of the program (note that the rest of the program that defines the other classes remains unchanged):\n\n```python\nclass Triangle(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * (self.width - i))\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\nprint()\n\nt1 = Triangle(7)\nt1.draw()\n```\n\nThe output of this modified program is as follows:\n```default\n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n\n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n\n* * * * * * * \n* * * * * *\n* * * * *\n* * * *\n* * *\n* *\n* \n```\n\nPay close attention to the following statements in the draw function of the `Triangle` class:\n\n```python\nfor i in range(self.width):\n    print(\"* \" * (self.width - i))\n```\n\nThe variable `i` iterates from 0 through the width of the triangle (minus one). Since the triangle is seven units long, then `i` iterates from 0 through 6 (exactly seven times). The first time in the for loop, the variable `i` is equal to 0. Therefore, the number of asterisks displayed is `7 – 0 = 7`. The next time through the loop, `i` is equal to 1, and `7 – 1 = 6` asterisks are displayed. This continues until the last time through the loop, where `i` is equal to 6 and `7 – 6 = 1` asterisk is displayed.\n\n### Acivity: Zooland\n\nNow that you have an idea about polymorphism and method lookup, let's look at a hypothetical example in which we'll be more concerned about the placement of the polymorphic methods rather than their actual implementation.\n\nSuppose that you are writing a program to model (i.e., programmatically represent) the types of animals that are in a zoo. Such a situation would easily lend itself to inheritance, since there are multiple animals that are similar in nature (and could therefore inherit similar traits from a superclass). In fact, a possible class diagram for such a program is shown on the next page.\n\nThe class diagram shows how a variety of animals are related. All animals move; therefore, a `move` function is defined in the topmost `Animal` class. That particular version of `move` is implemented as: “move in a given direction using four limbs, all of which are in contact with the ground at some point.”\n\nOf course this definition of `move` is not accurate for some of the animals that are in the class diagram. The objective of this activity is to place one of the following alternate versions of `move` in the appropriate classes, such that all animals move in their proper way. Since the motivation behind inheritance is primarily to reduce code duplication, the goal is to place as few move functions in the hierarchy as possible. Here are the alternate versions of the `move` function:\n\n1. Move in a given direction using four limbs, all of which are in contact with the ground at some point (note that this is the version in the animal class);\n\n2. Move in a given direction using two limbs, both of which are in contact with the ground at some point;\n\n3. Move in a given direction using wings or wing-like body parts;\n\n4. Move in a given direction using six or more limbs, all of which are in contact with\nthe ground at some point;\n\n5. Move in a given direction using fins or fin-like body parts; and\n\n6. Move in a given direction by slithering on the ground.\n\nRemember that the higher up a function is in the inheritance hierarchy, the more classes it can be applied to. In addition, it is possible that a better result is obtained by removing or changing the version of `move` currently in the `Animal` class to another version. Note that in cases where an animal could potentially implement more than one of the given versions of `move`, assume that the animal only uses the more dominant version. For example, while an eagle could walk on two limbs, it predominantly flies through the air to move; therefore, use version (3).\n\n[image]\n\n\n## Multiple Inheritance\n\n\n\n","srcMarkdownNoYaml":"\n\n## Inheritance\n\nThe last major topic that was discussed in the object-oriented paradigm was inheritance. To review, there are cases where it is advantageous to have one class (called a subclass) inherit state and behavior from another class (called a superclass). Using inheritance allows us, among many other things, to avoid excessive repetition and code duplication. This makes maintaining code much easier.\n\nAs an example, let's assume that you are writing a program to store information about the kinds of vehicles that a car mechanic's garage may deal with on a daily basis. For simplicity, suppose that the mechanic only keeps track of the number of tires that a car has (yes, there are some cars that have three tires), whether the car has a working engine, and the car's owner. In this case, the car class would need three instance variables (one for each of the mentioned attributes). It may even have a function that allows a car's information to be output in a meaningful way (i.e., it would implement a `__str__` method). Even though the class is very basic, we'll use it to make a point. Here is the source code for the `Car` class, along with some sample testing code in the main part of the program:\n\n```python\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nprint(c1)\n```\n\nOf course, the output is fairly simple to determine:\n\n```default\nCar; owner=John, tires=4, engine=True\n```\n\nNow consider the case where, one day, the mechanic's garage decides to repair bicycles as well. A very quick fix would be to create a similar class just for bicycles. In fact, here are comparisons of the `Car` and `Bicycle` classes (with a slightly modified main part of the program):\n\n```python\nclass Car:\n\n    def __init__(self, name):\n        self.tires = 4\n        self.engine = True\n        self.owner = name\n\n    def __str__(self):\n        return \"Car; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Bicycle:\n\n    def __init__(self, name):\n        self.tires = 2\n        self.engine = False\n        self.owner = name\n\n    def __str__(self):\n        return \"Bicycle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\n\nprint(c1)\nprint(b1)\n```\n\nAnd here is the output of this modified program:\n\n```default\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\n```\n\nNotice the code duplication? In fact, the `Bicycle` class is almost an exact copy of the `Car` class. The only differences are that a bicycle has only two tires, has no engine, and is called a bicycle. As you might imagine, creating similar classes this way gets very ineffective the larger classes get, and the more classes an application requires. For example, what would need to be done if the garage decided to repair motorcycles as well? Expanding the example above, another class would have to be created. In fact, it would also be very similar to the `Car` class.\n\nWhat would happen if a mistake were made in the source code that implements the way that tires are accounted for? Or suppose that an adjustment needed to be made (e.g., adding another instance variable to keep track of a spare tire). In the best case, modifications to all three classes would have to be made, thereby increasing the chances of making mistakes and causing errors.\n\nAs discussed previously, the concept of inheritance allows us to create a superclass that can encapsulate all of the common members that one or more subclasses can share. The subclasses that are created from some superclass can be considered to be specific subtypes of the superclass.\n\nOne way to modify the code in the example above to utilize inheritance is to create a `Vehicle` superclass that defines all of the members that are shared among all types of vehicles in the application: cars, bicycle, and motorcycles. The car, bicycle, and motorcycle classes would then inherit from and become subclasses of the `Vehicle` class. This greatly helps to reduce code duplication. To illustrate this, here are modified classes, along with some test code, that updates the classes above and implements inheritance:\n\n```python\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n    def __str__(self):\n        return \"Car; \" + super().__str__()\n\n\nclass Bicycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle; \" + super().__str__()\n\n\nclass Motorcycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\nc1 = Car(\"John\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(b1)\nprint(m1)\n```\n\nAnd here is the output of the program\n\n```default\nCar; owner=John, tires=4, engine=True\nBicycle; owner=Jane, tires=2, engine=False\nMotorcycle; owner=Randy, tires=2, engine=True\n```\n\nLook over the code above and see if it makes sense to you. Notice the default values of None for the variables `tires` and `engine`. These values are overwritten in the subclasses, depending on which subclass is initialized, as follows:\n\n|Class|tires|engine|\n|:----|:--|:----|\n|Vehicle|None|None|\n|Car|4|True|\n|Bicycle|2|False|\n|Motorcycle|2|True|\n\nAlso notice that the constructor of the `Vehicle` class (the superclass) is called in the constructor of each of the subclasses. In fact, this is the first statement in the constructors of the subclasses. That is, the initialization of a car, bicycle, and motorcycle first means to initialize a vehicle. This sets default values for the variables `tires` and `engine`. The owner of the vehicle is passed in when instantiating each of the subclasses, and is forwarded to the superclass (where the value is formally assigned). Any remaining initialization of the subclasses is done after the call to the constructor in the superclass (i.e., specific values for the variables `tires` and `engine`).\n\nAlso, the class output magic function `__str__` also calls the matching function in the `Vehicle` superclass. Why? Well, it actually generates the appropriate output for any kind of vehicle (i.e., owner, number of tires, and whether or not it has an engine). The only distinguishing characteristic is the actual name of the class. Therefore, the subclasses first generate a string matching their name followed by a call to the superclass function (which generates a string containing the information specified above).\n\nAs a last modification, note that bicycles and motorcycles have the same number of tires. Since we can have many levels of inheritance, let's try to add a generic `Cycle` class that encapsulates the attributes shared by all kinds of *cycles* (i.e., bicycles and motorcycles). To be clear, the application now has the following class diagram:\n\n[image]\n\n::: {.callout-tip title=\"Activity\"}\nImplement the `Cycle` class; then, modify the `Bicycle` and `Motorcycle` classes to inherit from the `Cycle` class.\n:::\n\nThe act of designing an application, particularly a large one, requires consideration of many factors that help to ensure its success. That is, there are ideas that must be considered in order to make designing an application easier. Much of the remainder of this lesson is dedicated to identifying such techniques.\n\n\n## Abstraction and Modularization\n\n::: {.callout-tip title=\"Definition\"}\n**Abstraction** is the ability to ignore the details of parts of a system in order to focus our attention at a _higher_ level.\n:::\n\nThink of a Google map. When zoomed out to its default level, an entire city may be visible. Detailed street names, building structures, and so on, are invisible as they would clutter the map. Similarly, areas surrounding the city (e.g., state, region, country) are not visible. Zooming in reveals more detail of a part of the city; however, some of the surrounding detail that was present before is lost. Zooming out may further hide details, but bring in surrounding cities and towns. These *zoom levels* present just enough information that is required to process the map at that level.\n\nThe object-oriented paradigm is actually emblematic of this concept. Consider the traffic simulation application that was discussed in a previous lesson. In case you have forgotten, its goal was to model vehicle traffic in a large city for the purpose of analyzing how it manages traffic during rush hour. This kind of application would be useful in learning about traffic patterns, congestion, and so on. In fact, it could help to redesign roads, entrances to and exits from highways and interstates, the placement and timing of traffic signals, etc. As discussed, such an application may include classes for cars, pickup trucks, buses, tractor trailers, motorcycles, and so on, since all of these things contribute to the traffic in the city. We initially modeled it with the following class diagram:\n\n[image]\n\nIn the simulation, the way in which cars, pickup trucks, buses, motorcycles, and so on, are implemented doesn't matter to a city official using it to make zoning decisions. Those details are abstracted away from the user. As another example, the programmers tasked with extending the traffic simulation don't necessarily need to know how a bus works to, say, support school zones in the simulation.\n\nAt its most basic level, the concept of an object represents a way of abstracting away data and operations into a single thing, the data being state and operations being behavior. To instantiate an object and use it in some programming context, there is no real need to know how some behavior is actually implemented, for example. Simply understanding the interface (i.e., how to invoke some sort of behavior) is enough. We just need to know what function to call, what parameters to pass it, and if we should expect a return value.\n\n::: {.callout-tip title=\"Modularization\"}\n**Modularization** is the act of dividing a whole into well-defined parts that can be built and examined separately.\n:::\n\nIt is important to note, however, that the parts typically interact and must do so in well-defined ways. This facilitates reasoning about and maintenance of the application. In the traffic simulation example, the act of designing various classes to best represent the components of the application inherently demonstrates modularization.\n\nOften, abstraction and modularization go hand-in-hand. In a sense, modularization results in different levels of abstraction throughout some application. Moreover, the goal of setting levels of abstraction in an application (for example, to make maintenance easier and more manageable) motivates modularization\n\n## Polymorphism\n\nLet's go back to the mechanic's garage problem that was used earlier. Notice that all of the classes involved have their own `__str__` function. When we execute a statement such as `print(b1)`, which specific `__str__` function is executed?\n\n::: {.callout-tip title=\"Modularization\"}\n**Method lookup** solves the problem of finding the right method to call in a class hierarchy. The idea of having multiple methods with the same name in multiple classes is called **polymorphism**.\n:::\n\nAt first, it may seem confusing to have multiple functions in different classes with the same name; however, it turns out to be a very handy feature of object-oriented programming. Let's answer the question that was initially posed: when we execute a statement such as `print(b1)`, which specific `__str__` function is executed? The variable `b1` is a bicycle. Therefore, if an `__str__` function exists in the Bicycle class, then it is executed. Indeed, one exists in the class. In fact, it contains the following single statement:\n\n```python\nreturn \"Bicycle; \" + super().__str__()\n```\n\nNote that the function also calls the `__str__` function in the `Cycle` class via the right-hand part of the statement: `super().__str__()`. The entire string cannot be returned until `__str__` in the `Cycle` class has finished execution. It, too, contains only a single statement:\n\n```python\nreturn super().__str__()\n```\n\nClearly, it calls the `__str__` function in the `Vehicle` class, which returns a string containing the owner of the vehicle, its number of tires, and whether it has an engine or not:\n\n```python\n return \"owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n```\n\nIn the end, all three `__str__` output functions are executed with the statement `print(b1)`. What about the statement print(c1)? In a similar manner, we see that the `__str__` function in the `Car` class is executed first (since `c1` is an instance of the `Car` class). This function calls its matching function in the `Vehicle` class (in order to actually produce the string containing the car's owner, number of tires, and whether it has an engine or not).\n\nIn both of these examples, the function that is called is the one located in the object reference's defining class. That is, since `b1` is a bicycle, then the function in the Bicycle class is called. Similarly, since `c1` is a car, then the function in the `Car` class is called. The fact that there may be chained calls to matching functions in superclasses is just coincidence (however, it is intentional in order to produce the proper output).\n\nLet's take a look at a slightly modified version of the previous example. First, the classes:\n\n```python\nclass Vehicle:\n\n    def __init__(self, name):\n        self.tires = None\n        self.engine = None\n        self.owner = name\n\n    def __str__(self):\n        return \"Vehicle; owner={}, tires={}, engine={}\".format(self.owner, self.tires, self.engine)\n\n\nclass Car(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 4\n        self.engine = True\n\n\nclass Cycle(Vehicle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.tires = 2\n\n\nclass Bicycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = False\n\n    def __str__(self):\n        return \"Bicycle!\"\n\n\nclass Motorcycle(Cycle):\n\n    def __init__(self, name):\n        super().__init__(name)\n        self.engine = True\n\n    def __str__(self):\n        return \"Motorcycle; \" + super().__str__()\n\n\n# main\nc1 = Car(\"John\")\nc2 = Cycle(\"Samantha\")\nb1 = Bicycle(\"Jane\")\nm1 = Motorcycle(\"Randy\")\n\nprint(c1)\nprint(c2)\nprint(b1)\nprint(m1)\n```\n\nThis example has the same classes as the previous one. However, the `__str__` functions have been changed in various ways. \n\n::: {.callout-tip title=\"Activity\"}\nGiven the discussion above about method lookup, can you explain what the print statements in the main part of the program will produce?\n:::\n\nMethod lookup is essentially a simple concept. If a specified function is not found in a class, then a search for the matching function is performed in the superclass. In fact, method lookup works by continuously trying to find a matching function in the superclass hierarchy until one is found. If one is not found, then an error occurs.\n\nPolymorphism is a powerful concept. It allows us to specify a function at a superclass level (including any desired implementation), and then to overwrite it at lower levels of the class hierarchy (i.e., in subclasses). Consider this a way to specialize or refine behaviors defined in superclasses.\n\nLet's look at an example of how this can be leveraged to produce efficient programs. Consider a scenario in which you want to write a program that can draw basic shapes (e.g., a rectangle). Such a program can be designed by creating a rectangle class that stores its length and width in instance variables, and has a draw function that produces a representation of that shape (for now, just using characters that can be found on a keyboard). A simple class diagram for this could be the following:\n\n[image]\n\nAnd here's one possible method of implementing the class\n\n```python\nclass Rectangle:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\nr1 = Rectangle(10, 4)\nr1.draw()\n```\n\nLastly, here's the output produced by the program above:\n\n```default\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\n* * * * * * * * * *\n```\n\nSure enough, we asked for a rectangle that is 10 units long by 4 units high. And that's what we got! Now suppose that we want to expand the program to be able to accommodate squares. Squares are very similar to rectangles except that their length and width are always equal. Considering what we now know about inheritance and polymorphism, we could create a generic shape class that both squares and rectangles could inherit from.\n\nHere's an updated version that implements this:\n\n```python\nclass Shape:\n\n    def __init__(self, l, w):\n        self.length = l\n        self.width = w\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * self.length)\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, l, w):\n        super().__init__(l, w)\n\n\nclass Square(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\n```\n\nThe `Square` and `Rectangle` classes are subclasses of the `Shape` class. Note that they have no instance variables or functions unique to them. That is, they inherit everything from their superclass. The only difference between the two is that the constructor of the `Square` class takes only one argument, while the constructor of the `Rectangle` class takes two arguments. Within their individual implementations, they both call the constructor of the `Shape` class.\n\nWhen we want to draw a square or rectangle, we call the `draw` function. Method lookup makes it easy to see that the `draw` function in the `Shape` class will be executed. Why? Because the `Square` and `Rectangle` classes don't have a `draw` function of their own, but their superclass (the `Shape` class) does.\n\nSince one of the benefits of inheritance is to increase code reuse and to ease expansion and application feature enhancement, let's do precisely that by adding the ability to create and draw triangles. To simplify this, let's just consider right-angled isosceles triangles (i.e., the two sides making up the right angle are of equal length). Since triangles are shapes too, it makes sense to make them a subclass of the `Shape` class, yielding the following modified class diagram:\n\n[image]\n\nNote the specification of the `draw` function in the triangle class. The shape of a triangle is different from that of a square or a rectangle, and the process of drawing that shape is therefore different. Polymorphism allows us to create another function, also called `draw`, but specifically for triangles. This overwrites the `draw` function specified in the `Shape` class, and effectively specializes the draw behavior for a triangle. This version of draw would only be executed on an object reference of the type `Triangle`.\n\nHere is the new `Triangle` class, along with an updated main part of the program (note that the rest of the program that defines the other classes remains unchanged):\n\n```python\nclass Triangle(Shape):\n\n    def __init__(self, l):\n        super().__init__(l, l)\n\n    def draw(self):\n        for i in range(self.width):\n            print(\"* \" * (self.width - i))\n\n\nr1 = Rectangle(12, 4)\nr1.draw()\nprint()\n\ns1 = Square(6)\ns1.draw()\nprint()\n\nt1 = Triangle(7)\nt1.draw()\n```\n\nThe output of this modified program is as follows:\n```default\n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n* * * * * * * * * * * * \n\n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n* * * * * * \n\n* * * * * * * \n* * * * * *\n* * * * *\n* * * *\n* * *\n* *\n* \n```\n\nPay close attention to the following statements in the draw function of the `Triangle` class:\n\n```python\nfor i in range(self.width):\n    print(\"* \" * (self.width - i))\n```\n\nThe variable `i` iterates from 0 through the width of the triangle (minus one). Since the triangle is seven units long, then `i` iterates from 0 through 6 (exactly seven times). The first time in the for loop, the variable `i` is equal to 0. Therefore, the number of asterisks displayed is `7 – 0 = 7`. The next time through the loop, `i` is equal to 1, and `7 – 1 = 6` asterisks are displayed. This continues until the last time through the loop, where `i` is equal to 6 and `7 – 6 = 1` asterisk is displayed.\n\n### Acivity: Zooland\n\nNow that you have an idea about polymorphism and method lookup, let's look at a hypothetical example in which we'll be more concerned about the placement of the polymorphic methods rather than their actual implementation.\n\nSuppose that you are writing a program to model (i.e., programmatically represent) the types of animals that are in a zoo. Such a situation would easily lend itself to inheritance, since there are multiple animals that are similar in nature (and could therefore inherit similar traits from a superclass). In fact, a possible class diagram for such a program is shown on the next page.\n\nThe class diagram shows how a variety of animals are related. All animals move; therefore, a `move` function is defined in the topmost `Animal` class. That particular version of `move` is implemented as: “move in a given direction using four limbs, all of which are in contact with the ground at some point.”\n\nOf course this definition of `move` is not accurate for some of the animals that are in the class diagram. The objective of this activity is to place one of the following alternate versions of `move` in the appropriate classes, such that all animals move in their proper way. Since the motivation behind inheritance is primarily to reduce code duplication, the goal is to place as few move functions in the hierarchy as possible. Here are the alternate versions of the `move` function:\n\n1. Move in a given direction using four limbs, all of which are in contact with the ground at some point (note that this is the version in the animal class);\n\n2. Move in a given direction using two limbs, both of which are in contact with the ground at some point;\n\n3. Move in a given direction using wings or wing-like body parts;\n\n4. Move in a given direction using six or more limbs, all of which are in contact with\nthe ground at some point;\n\n5. Move in a given direction using fins or fin-like body parts; and\n\n6. Move in a given direction by slithering on the ground.\n\nRemember that the higher up a function is in the inheritance hierarchy, the more classes it can be applied to. In addition, it is possible that a better result is obtained by removing or changing the version of `move` currently in the `Animal` class to another version. Note that in cases where an animal could potentially implement more than one of the given versions of `move`, assume that the animal only uses the more dominant version. For example, while an eagle could walk on two limbs, it predominantly flies through the air to move; therefore, use version (3).\n\n[image]\n\n\n## Multiple Inheritance\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"cosmo","title":"02 More on Objects"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}